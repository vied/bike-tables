<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Bike Tire Size Table</title>
  <style>
    body { font-family: system-ui, Arial, sans-serif; margin: 24px; }
    table { border-collapse: collapse; width: 100%; }
    th, td { border: 1px solid #ddd; padding: 8px; vertical-align: top; }
    thead th { position: sticky; top: 0; background: #fff; z-index: 1; }
    thead input { width: 100%; box-sizing: border-box; padding: 6px; }
    .num { text-align: right; font-variant-numeric: tabular-nums; }
    .note { color:#444; margin: 10px 0 16px; max-width: 70ch; }
    .rowcount { margin-top: 10px; color: #444; }
  </style>
</head>
<body>
  <h1>Wheel OD estimator</h1>
  <div class="note">
    Total wheel diameter is estimated as <b>BSD + 2Ã—(tire width)</b>, using tire width as a proxy for tire height.
    Real outside diameter varies by tire model, rim width, and pressure.
  </div>

  <table id="tireTable">
    <thead>
      <tr>
        <th class="num">BSD (mm)<br/><input data-col="bsd_mm" placeholder="e.g. 622" /></th>
        <th class="num">Tire width (mm)<br/><input data-col="width_mm" placeholder="e.g. >=40 or 35-45" /></th>
        <th class="num">Tire width (in)<br/><input data-col="width_in" placeholder="e.g. 1.5-2.4" /></th>
        <th class="num">Total wheel diameter (mm)<br/><input data-col="od_mm" placeholder="e.g. >=700" /></th>
      </tr>
    </thead>
    <tbody></tbody>
  </table>

  <div class="rowcount" id="rowCount"></div>

<script type="module">
  const tbody = document.querySelector("#tireTable tbody");
  const inputs = Array.from(document.querySelectorAll("thead input"));
  const rowCount = document.querySelector("#rowCount");

  function parseNumericFilter(raw) {
    const s = (raw ?? "").trim();
    if (!s) return null;

    const mComp = s.match(/^(>=|<=|>|<)\s*(-?\d+(\.\d+)?)$/);
    if (mComp) return { type: "comp", op: mComp[1], val: Number(mComp[2]) };

    const mRange = s.match(/^(-?\d+(\.\d+)?)\s*-\s*(-?\d+(\.\d+)?)$/);
    if (mRange) {
      const a = Number(mRange[1]), b = Number(mRange[3]);
      return { type: "range", min: Math.min(a,b), max: Math.max(a,b) };
    }

    if (!Number.isNaN(Number(s))) return { type: "eq", val: Number(s) };

    return { type: "text", val: s.toLowerCase() };
  }

  function matchCell(value, filterRaw) {
    const f = (filterRaw ?? "").trim();
    if (!f) return true;

    if (typeof value === "number") {
      const nf = parseNumericFilter(f);
      if (!nf) return true;
      if (nf.type === "eq") return value === nf.val;
      if (nf.type === "range") return value >= nf.min && value <= nf.max;
      if (nf.type === "comp") {
        if (nf.op === ">=") return value >= nf.val;
        if (nf.op === "<=") return value <= nf.val;
        if (nf.op === ">")  return value > nf.val;
        if (nf.op === "<")  return value < nf.val;
      }
      if (nf.type === "text") return String(value).includes(nf.val);
      return true;
    }

    return String(value ?? "").toLowerCase().includes(f.toLowerCase());
  }

  function getFilters() {
    const filters = {};
    for (const input of inputs) filters[input.dataset.col] = input.value;
    return filters;
  }

  function applyFilters(rows, filters) {
    return rows.filter(r =>
      matchCell(r.bsd_mm, filters.bsd_mm) &&
      matchCell(r.width_mm, filters.width_mm) &&
      matchCell(r.width_in, filters.width_in) &&
      matchCell(r.od_mm, filters.od_mm)
    );
  }

  function render(rows) {
    tbody.innerHTML = rows.map(r => `
      <tr>
        <td class="num">${r.bsd_mm}</td>
        <td class="num">${r.width_mm}</td>
        <td class="num">${r.width_in.toFixed(2)}</td>
        <td class="num">${Math.round(r.od_mm)}</td>
      </tr>
    `).join("");
    rowCount.textContent = `${rows.length} row(s)`;
  }

  function cartesianProduct(bsds, widths) {
    // Small optimization: build in a stable sort order (BSD asc, width asc)
    const rows = [];
    const bsdsSorted = [...bsds].sort((a,b) => a-b);
    const widthsSorted = [...widths].sort((a,b) => a-b);

    for (const bsd of bsdsSorted) {
      for (const w of widthsSorted) {
        const width_in = w / 25.4;
        const od_mm = bsd + 2 * w; // estimated total OD
        rows.push({ bsd_mm: bsd, width_mm: w, width_in, od_mm });
      }
    }
    return rows;
  }

  // Load compact data
  const raw = await (await fetch("./data/tire-sizes.json")).json();
  const DATA = cartesianProduct(raw.bsds_mm ?? [], raw.tire_widths_mm ?? []);

  function refresh() {
    const filtered = applyFilters(DATA, getFilters());
    render(filtered);
  }

  inputs.forEach(i => i.addEventListener("input", refresh));
  render(DATA);
</script>
</body>
</html>
