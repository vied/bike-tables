<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Bike Tire Size Table</title>
  <style>
    body { font-family: system-ui, Arial, sans-serif; margin: 24px; }
    table { border-collapse: collapse; width: 100%; }
    th, td { border: 1px solid #ddd; padding: 8px; vertical-align: top; }
    thead th { position: sticky; top: 0; background: #fff; z-index: 1; }
    thead input { width: 100%; box-sizing: border-box; padding: 6px; }
    .num { text-align: right; font-variant-numeric: tabular-nums; }
    .note { color:#444; margin: 10px 0 16px; max-width: 70ch; }
    .rowcount { margin-top: 10px; color: #444; }
  </style>
</head>
<body>
  <h1>Wheel OD estimator</h1>
  <div class="note">
    Total wheel diameter is estimated as <b>BSD + 2Ã—(tire width)</b>, using tire width as a proxy for tire height.
    Real outside diameter varies by tire model, rim width, and pressure.
  </div>

  <table id="tireTable">
    <thead>
      <tr>
        <th class="num">BSD (mm)<br/><input data-col="bsd_mm" placeholder="e.g. 622" /></th>
        <th class="num">Tire width (mm)<br/><input data-col="width_mm" placeholder="e.g. >=40 or 35-45" /></th>
        <th class="num">Tire width (in)<br/><input data-col="width_in" placeholder="e.g. 1.5-2.4" /></th>
        <th class="num">Total wheel diameter (mm)<br/><input data-col="od_mm" placeholder="e.g. >=700" /></th>
      </tr>
    </thead>
    <tbody></tbody>
  </table>

  <div class="rowcount" id="rowCount"></div>

<script type="module">
  const tbody = document.querySelector("#tireTable tbody");
  const inputs = Array.from(document.querySelectorAll("thead input"));
  const rowCount = document.querySelector("#rowCount");

  function parseNumericFilter(raw) {
    const s = (raw ?? "").trim();
    if (!s) return null;

    const mComp = s.match(/^(>=|<=|>|<)\s*(-?\d+(\.\d+)?)$/);
    if (mComp) return { type: "comp", op: mComp[1], val: Number(mComp[2]) };

    const mRange = s.match(/^(-?\d+(\.\d+)?)\s*-\s*(-?\d+(\.\d+)?)$/);
    if (mRange) {
      const a = Number(mRange[1]), b = Number(mRange[3]);
      return { type: "range", min: Math.min(a,b), max: Math.max(a,b) };
    }

    if (!Number.isNaN(Number(s))) return { type: "eq", val: Number(s) };

    return { type: "text", val: s.toLowerCase() };
  }

  function matchCell(value, filterRaw) {
    const f = (filterRaw ?? "").trim();
    if (!f) return true;

    if (typeof value === "number") {
      const nf = parseNumericFilter(f);
      if (!nf) return true;
      if (nf.type === "eq") return value === nf.val;
      if (nf.type === "range") return value >= nf.min && value <= nf.max;
      if (nf.type === "comp") {
        if (nf.op === ">=") return value >= nf.val;
        if (nf.op === "<=") return value <= nf.val;
        if (nf.op === ">")  return value > nf.val;
        if (nf.op === "<")  return value < nf.val;
      }
      if (nf.type === "text") return String(value).includes(nf.val);
      return true;
    }

    return String(value ?? "").toLowerCase().includes(f.toLowerCase());
  }

  function getFilters() {
    const filters = {};
    for (const input of inputs) filters[input.dataset.col] = input.value;
    return filters;
  }

  function applyFilters(rows, filters) {
    return rows.filter(r =>
      matchCell(r.bsd_mm, filters.bsd_mm) &&
      matchCell(r.width_mm, filters.width_mm) &&
      matchCell(r.width_in, filters.width_in) &&
      matchCell(r.od_mm, filters.od_mm)
    );
  }

  function render(rows) {
    tbody.innerHTML = rows.map(r => `
      <tr>
        <td class="num">${r.bsd_mm}</td>
        <td class="num">${r.width_mm}</td>
        <td class="num">${r.width_in.toFixed(2)}</td>
        <td class="num">${Math.round(r.od_mm)}</td>
      </tr>
    `).join("");
    rowCount.textContent = `${rows.length} row(s)`;
  }

  function cartesianProduct(bsds, widths) {
    // Small optimization: build in a stable sort order (BSD asc, width asc)
    const rows = [];
    const bsdsSorted = [...bsds].sort((a,b) => a-b);
    const widthsSorted = [...widths].sort((a,b) => a-b);

    for (const bsd of bsdsSorted) {
      for (const w of widthsSorted) {
        const width_in = w / 25.4;
        const od_mm = bsd + 2 * w; // estimated total OD
        rows.push({ bsd_mm: bsd, width_mm: w, width_in, od_mm });
      }
    }
    return rows;
  }

  // Load compact data
const res = await fetch("./data/tire-sizes.json");
if (!res.ok) throw new Error(`Could not load JSON: HTTP ${res.status}`);
const raw = await res.json();

// Accept multiple shapes:
// 1) { bsds_mm: [...], tire_widths_mm: [...] }
// 2) { bsds: [...], widths_mm: [...] } etc.
// 3) { bsds_mm: [...], tireWidthsMm: [...] } etc.
let bsds =
  raw?.bsds_mm ?? raw?.bsds ?? raw?.BSDs ?? raw?.bsd_mm ?? raw?.bsd ?? null;

let widths =
  raw?.tire_widths_mm ?? raw?.widths_mm ?? raw?.widths ?? raw?.tireWidthsMm ?? null;

// If someone accidentally left the *old* array-of-rows format in place,
// try to recover by extracting unique BSD/width values.
if (Array.isArray(raw) && (!bsds || !widths)) {
  const b = new Set();
  const w = new Set();
  for (const r of raw) {
    if (typeof r?.bsd_mm === "number") b.add(r.bsd_mm);
    if (typeof r?.width_mm === "number") w.add(r.width_mm);
    if (typeof r?.etrto === "string") {
      const m = r.etrto.trim().match(/^(\d+)\s*-\s*(\d+)$/);
      if (m) { w.add(Number(m[1])); b.add(Number(m[2])); }
    }
  }
  bsds = [...b];
  widths = [...w];
}

if (!Array.isArray(bsds) || !Array.isArray(widths) || bsds.length === 0 || widths.length === 0) {
  document.getElementById("rowCount").textContent =
    "ERROR: JSON loaded, but couldn't find non-empty bsds_mm and tire_widths_mm arrays.";
  console.log("Loaded JSON:", raw);
}

const DATA = cartesianProduct(bsds ?? [], widths ?? []);
render(DATA);

</script>
</body>
</html>
